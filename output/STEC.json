{"handlers":[{"code":"keybindPresets[\"maneuver\"] = KeybindController()\nkeybindPresets[\"maneuver\"].Init = function()end\n\n-- Maneuver\nkeybindPresets[\"maneuver\"].keyDown.up.Add(function () ship.direction.z = 1 end)\nkeybindPresets[\"maneuver\"].keyUp.up.Add(function () ship.direction.z = 0 end)\nkeybindPresets[\"maneuver\"].keyDown.down.Add(function () ship.direction.z = -1 end)\nkeybindPresets[\"maneuver\"].keyUp.down.Add(function () ship.direction.z = 0 end)\nkeybindPresets[\"maneuver\"].keyDown.left.Add(function () ship.direction.x = -1 end)\nkeybindPresets[\"maneuver\"].keyUp.left.Add(function () ship.direction.x = 0 end)\nkeybindPresets[\"maneuver\"].keyDown.right.Add(function () ship.direction.x = 1 end)\nkeybindPresets[\"maneuver\"].keyUp.right.Add(function () ship.direction.x = 0 end)\nkeybindPresets[\"maneuver\"].keyDown.forward.Add(function () ship.direction.y = 1 end)\nkeybindPresets[\"maneuver\"].keyUp.forward.Add(function () ship.direction.y = 0 end)\nkeybindPresets[\"maneuver\"].keyDown.backward.Add(function () ship.direction.y = -1 end)\nkeybindPresets[\"maneuver\"].keyUp.backward.Add(function () ship.direction.y = 0 end)\n\nkeybindPresets[\"maneuver\"].keyDown.yawleft.Add(function () ship.rotation.y = -1 end)\nkeybindPresets[\"maneuver\"].keyUp.yawleft.Add(function () ship.rotation.y = 0 end)\nkeybindPresets[\"maneuver\"].keyDown.yawright.Add(function () ship.rotation.y = 1 end)\nkeybindPresets[\"maneuver\"].keyUp.yawright.Add(function () ship.rotation.y = 0 end)\n\nkeybindPresets[\"maneuver\"].keyDown.brake.Add(function () ship.brake = true end)\nkeybindPresets[\"maneuver\"].keyUp.brake.Add(function () ship.brake = false end)\n\nkeybindPresets[\"maneuver\"].keyDown.stopengines.Add(function () if not SHUD.Enabled then mouse.unlock() mouse.enabled = false end end, \"Free Look\")\nkeybindPresets[\"maneuver\"].keyUp.stopengines.Add(function () SHUD.Select() if not SHUD.Enabled then mouse.lock() mouse.enabled = true end end)\n\nkeybindPresets[\"maneuver\"].keyUp.speedup.Add(function () SHUD.Enabled = not SHUD.Enabled end)\nkeybindPresets[\"maneuver\"].keyUp.speeddown.Add(function () if mouse.enabled then mouse.unlock() mouse.enabled = false else mouse.lock() mouse.enabled = true end end, \"Mouse Steering\")\n\nkeybindPreset = \"maneuver\"\n\nSHUD.Init(system, unit, keybindPresets[keybindPreset])\n\nTask(function()\n    coroutine.yield()\n    SHUD.FreezeUpdate = true\n    local endTime = system.getTime() + 2\n    while system.getTime() < endTime do\n            coroutine.yield()\n    end\n    SHUD.FreezeUpdate = false\n    SHUD.IntroPassed = true\nend)\n\nSHUD.Markers = {\n    {\n        Position = function() return ship.world.position + (ship.target.prograde() * 2) end,\n        Class = \"prograde\"\n    },\n    {\n        Position = function() return ship.world.position + (ship.target.retrograde() * 2) end,\n        Class = \"retrograde\"\n    },\n    {\n        Position = function() return ship.world.position + (ship.target.radial() * 2) end,\n        Class = \"radial\"\n    },\n    {\n        Position = function() return ship.world.position + (ship.target.antiradial() * 2) end,\n        Class = \"antiradial\"\n    },\n    {\n        Position = vec3(-15973, 106446, -60333),\n        Class = \"target\",\n        Name = \"Shadow Templar HQ\",\n        ShowDistance = true\n    }\n}\n\nship.throttle = 0.2","key":1,"filter":{"slotKey":"-1","args":[],"signature":"start()"}},{"code":"system.showScreen(0)","key":2,"filter":{"slotKey":"-1","args":[],"signature":"stop()"}},{"code":"keybindPresets[keybindPreset].Call(action, \"down\")","key":3,"filter":{"slotKey":"-2","args":[{"variable":"*"}],"signature":"actionStart(action)"}},{"code":"keybindPresets[keybindPreset].Call(action, \"up\")","key":4,"filter":{"slotKey":"-2","args":[{"variable":"*"}],"signature":"actionStop(action)"}},{"code":"keybindPresets[keybindPreset].Call(action, \"loop\")","key":5,"filter":{"slotKey":"-2","args":[{"variable":"*"}],"signature":"actionLoop(action)"}},{"code":"mouse.apply()\nship.apply()","key":6,"filter":{"slotKey":"-2","args":[],"signature":"flush()"}},{"code":"if SHUD then SHUD.Render() end","key":7,"filter":{"slotKey":"-1","args":[{"value":"HUD"}],"signature":"tick(timerId)"}},{"code":"if SHUD then SHUD.Update() end","key":8,"filter":{"slotKey":"-2","args":[],"signature":"update()"}},{"code":"function DynamicDocument(template)\n    local self = {}\n    self.template = template or \"\"\n    local buffer = \"\"\n    local callbacks = {}\n    self.tree = {}\n\n    local emptyTags = {\n        br = true,\n        hr = true,\n        img = true,\n        embed = true,\n        param = true,\n        area = true,\n        col = true,\n        input = true,\n        meta = true,\n        link = true,\n        base = true,\n        basefont = true,\n        iframe = true,\n        isindex = true,\n        circle = true,\n        polygon = true,\n        line = true,\n        rect = true,\n        use = true\n    }\n\n    function table.indexOf(val, table)\n        for k, v in ipairs(table) do\n            if v == val then return k end\n        end\n        return nil\n    end\n\n    function self.makeFunc(string)\n        local val = \"nil\"\n        if callbacks[string] == nil then\n            local e, f = pcall(load(\"return function() return \"..string..\" end\", nil, \"t\", _ENV))\n            if e then\n                callbacks[string] = f\n                val = f()\n                if type(val) == \"function\" then\n                    callbacks[string] = f()\n                    val = val()\n                end\n            end\n        else\n            val = callbacks[string]()\n        end\n        return val\n    end\n\n    local function parseTemplate(template)\n        local level = 0\n        local stack = {}\n        local tree = {}\n        tree.dd = {}\n        table.insert(stack, tree)\n        local node = {}\n\n        for b, op, tag, attr, op2, bl1, val, bl2 in string.gmatch(template, \"(<)(%/?!?)([%w:_-'\\\\\\\"%[]+)(.-)(%/?%-?)>([%s\\r\\n\\t]*)([^<]*)([%s\\r\\n\\t]*)\") do\n            tag = string.lower(tag)\n            if op == \"/\" then\n                if level==0 then return tree end\n                level = level - 1\n                table.remove(stack)\n            else\n                local function isDdAttr(str)\n                    local dd = \"dd-\"\n                    return str:sub(1, #dd) == dd\n                end\n                level = level + 1\n                node = {}\n                node.name = tag\n                node.children = {}\n                node.attr = {}\n                if stack[level-1] then \n                    node.parent = stack[level-1][#stack[level-1]]\n                else\n                    node.parent = nil\n                end\n        \n                if attr ~= \"\" then\n                    for n, v in string.gmatch(attr, \"%s([^%s=]+)=\\\"([^\\\"]+)\\\"\") do\n                        node.attr[n] = string.gsub(v, '\"', '[^\\\\]\\\\\"')\n                        if isDdAttr(n) then\n                            if not tree.dd[n] then tree.dd[n] = {} end\n                            table.insert(tree.dd[n], node)\n                        end\n                    end\n                    for n, v in string.gmatch(attr, \"%s([^%s=]+)='([^']+)'\") do\n                        node.attr[n] = string.gsub(v, '\"', '[^\\\\]\\\\\"')\n                        if isDdAttr(n) then\n                            if not tree.dd[n] then tree.dd[n] = {} end\n                            table.insert(tree.dd[n], node)\n                        end\n                    end\n                end\n        \n                if not stack[level] then stack[level] = {} end\n                table.insert(stack[level], node)\n                if emptyTags[tag] then\n                    if val ~= \"\" then\n                        table.insert(stack[level], {\n                            name = \"textNode\",\n                            value = val\n                        })\n                    end\n                    node.children = {}\n                    level = level - 1\n                else\n                    if val ~= \"\" then\n                        table.insert(node.children, {\n                            name = \"textNode\",\n                            value = val\n                        })\n                    end\n                    table.insert(stack, node.children)\n                end\n            end\n        end\n        return tree\n    end\n\n    local function recompose(data, skipTransforms)\n        local stack = {data}\n        local d = \"\"\n\n        local function getLength(T)\n            local count = 0\n            for _ in pairs(T) do count = count + 1 end\n            return count\n        end\n\n        if not skipTransforms and getLength(data.dd) > 0 then\n            if data.dd[\"dd-repeat\"] then\n                for i=#data.dd[\"dd-repeat\"],1,-1 do\n                    local node = data.dd[\"dd-repeat\"][i]\n                    var, array = string.match(node.attr[\"dd-repeat\"], \"(.*) in (.*)\")\n                    node.attr[\"dd-repeat\"] = nil\n                    local precomposed = recompose({node}, true)\n                    local tmp = string.gmatch(precomposed, \"{{([^}}]+)}}\")\n                    local closures = {}\n                    for c in tmp do\n                        if string.match(c, var) then table.insert(closures, c) end\n                    end\n                    local buffer = \"\"\n                    local arr = self.makeFunc(array)\n                    for i=1,#arr do\n                        _ENV[var] = arr[i]\n                        local repeatBuffer = precomposed\n                        local reparsed = parseTemplate(repeatBuffer:gsub(\"^%s*(.-)%s*$\", \"%1\"))\n                        buffer = buffer .. recompose(reparsed)\n                    end\n                    node.children = {}\n                    node.name = \"textNode\"\n                    node.value = buffer\n                end\n            end\n            if data.dd[\"dd-if\"] then\n                for i=#data.dd[\"dd-if\"],1,-1 do\n                    local node = data.dd[\"dd-if\"][i]\n                    local pred = self.makeFunc(node.attr[\"dd-if\"])\n\n                    if pred then\n                        node.attr[\"dd-if\"] = nil\n                    else\n                        local ref = table.indexOf(node, node.parent.children)\n                        if ref then\n                            table.remove(node.parent.children, ref)\n                        end\n                        node = nil\n                        table.remove(data.dd[\"dd-if\"], i)\n                        data.dd[\"dd-if\"][i] = nil\n                    end\n                end\n            end\n            if data.dd[\"dd-init\"] then\n                for i=#data.dd[\"dd-init\"],1,-1 do\n                    local node = data.dd[\"dd-init\"][i]\n                    pcall(load(node.attr[\"dd-init\"], nil, \"t\", _ENV))\n                    node.attr[\"dd-init\"] = nil\n                end\n            end\n        end\n\n        while #stack ~= 0 do\n            node = stack[#stack][1]\n            if not node then break end\n            if node.name == \"textNode\" then\n                local val = node.value:gsub(\"^%s*(.-)%s*$\", \"%1\")\n                if not skipTransforms then val = self.transformClosures(val) end\n                d = d..val\n            else\n                d = d..\"\\n\"..string.rep (\" \", #stack-1)\n                d = d..\"<\"..node.name\n                if node.attr then\n                    for a, v in pairs(node.attr) do\n                        if not skipTransforms then\n                            a = self.transformClosures(a)\n                            v = self.transformClosures(v)\n                        end\n                        d = d..\" \"..a..'=\"'..v..'\"'\n                    end\n                end\n                if emptyTags[node.name] then d = d..\"/>\" else d = d..\">\" end\n            end\n            \n            if node.children and #node.children > 0 then\n                table.insert(stack, node.children)\n            else\n                table.remove(stack[#stack], 1)\n                if node.children and #node.children == 0 and not emptyTags[node.name] and not node.name == \"textNode\" then\n                    d = d..\"</\"..node.name..\">\"\n                end\n                while #stack > 0 and #stack[#stack] == 0 do\n                    table.remove(stack)\n                    if #stack > 0 then\n                        if #stack[#stack][1].children > 1 then\n                            d = d..\"\\n\"..string.rep(\" \", #stack-1)..\"</\"..stack[#stack][1].name..\">\"\n                        else\n                            d = d..\"</\"..stack[#stack][1].name..\">\"\n                        end\n                        table.remove(stack[#stack], 1)\n                    end\n                end\n            end\n        end\n        return d:match \"^%s*(.-)%s*$\"\n    end\n\n    function self.transformClosures(chunk)\n        local out = {}\n        local matches = string.gmatch(chunk, \"{{([^}}]+)}}\")\n        for i in matches do \n            table.insert(out, i) \n        end\n        if #out > 0 then\n            for i=1,#out do\n                local cl = out[i]\n                val = self.makeFunc(cl)\n                chunk = string.gsub(chunk, self.literalize(\"{{\"..cl..\"}}\"), tostring(val))\n            end\n        end\n        return chunk\n    end\n\n    function self.literalize(str)\n        return str:gsub(\"[%(%)%.%%%+%-%*%?%[%]%^%$]\", function(c) return \"%\" .. c end)\n    end\n\n    function self.Read()\n        return recompose(parseTemplate(self.template))\n    end\n    return self\nend","key":9,"filter":{"slotKey":"-2","args":[],"signature":"start()"}},{"code":"--[[\n    Shadow Templar Tag Manager\n    Version 1.02\n\t\n\tusage:\n\t\texampleGroup = TagManager(\"all,vertical\")\n\t\texampleGroup.Add(\"booster\")\n\t\texampleGroup.Remove(\"vertical\")\n\t\tengines.tags = exampleGroup \n]]\n\nfunction TagManager(tagString)\n\tself = {}\n\tlocal tagArray = {}\n\tlocal tags = \"\"\n\n\tlocal function explode(div,str)\n\t\tif (div=='') then return false end\n\t\tlocal pos,arr = 0,{}\n\t\tfor st,sp in function() return string.find(str,div,pos,true) end do\n\t\t  table.insert(arr,string.sub(str,pos,st-1))\n\t\t  pos = sp + 1\n\t\tend\n\t\ttable.insert(arr,string.sub(str,pos))\n\t\treturn arr\n\tend\n\t\n\tfunction self.tagsToString()\n\t\tif #tagArray == 0 then\n\t\t\ttags = \"all\"\n\t\telse\n\t\t\ttags = table.concat(tagArray,\",\")\n\t\tend\n\tend\n\t\n\tfunction self.Remove(s)\n\t\tif type(s) ~= \"string\" then error(\"[TagManager] Unable to remove a tag - Not a string\") end\n\t\tfor k,v in pairs(tagArray) do\n\t\t\tif s == v then\n\t\t\t\ttable.remove(tagArray,k)\n\t\t\tend\n\t\tend\n\t\tself.tagsToString()\n\tend\n\t\n\tfunction self.Add(s)\n\t\tif type(s) ~= \"string\" then error(\"[TagManager] Unable to add a tag - Not a string\") end\n\t\tfor k,v in pairs(tagArray) do\n\t\t\tif s == v then\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\t\ttable.insert(tagArray,s)\n\t\tself.tagsToString()\n\tend\n\t\n\tif (tagString ~= nil and type(tagString) == \"string\") then\n\t\tfor k,v in pairs(explode(\",\",tagString)) do\n\t\t\tself.Add(v)\n\t\tend\n\telse\n\t\tself.Add(\"all\")\n\tend\n\t\n\tsetmetatable (self, { __tostring = function (self) return tags end })\n\treturn self\nend\n","key":10,"filter":{"slotKey":"-3","args":[],"signature":"start()"}},{"code":"--[[\n    Shadow Templar Keybind Controller\n    Version 1.24\n    (c) Copyright 2019 Shadow Templar <http://www.shadowtemplar.org>\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n]]\n\nfunction Keybind(key)\n    local self = {}\n    self.Key = key\n    local bindings = {}\n\n    function self.Add(f, keybindName)\n        if type(f) ~= \"function\" then error(\"[Keybind] Unable to add callback - not a function\") end\n        table.insert(bindings, {Function = f, Name = keybindName})\n    end\n\n    function self.Remove(f)\n        if type(f) ~= \"function\" then error(\"[Keybind] Unable to remove callback - not a function\") end\n        local reverse = {}\n        for k,v in pairs(bindings) do reverse[v.Function]=k end\n        for k,v in pairs(reverse) do if k == f then bindings[v]=nil end end\n    end\n\n    function self.GetNames()\n        local out = {}\n        for k,v in pairs(bindings) do if v.Name then table.insert(out, v.Name) end end\n        return out\n    end\n\n    function self.Call() for k,v in pairs(bindings) do v.Function(self.Key) end end\n    return self\nend\n\nfunction KeybindController()\n    local self = {}\n    local keyList = {\n        \"forward\", \"backward\", \"left\", \"right\", \"yawleft\", \"yawright\", \"up\", \"down\", \"gear\", \"light\", \"landing\", \"brake\", \n        \"option1\", \"option2\", \"option3\", \"option4\", \"option5\", \"option6\", \"option7\", \"option8\", \"option9\",\n        \"stopengines\", \"speedup\", \"speeddown\", \"antigravity\", \"booster\"\n    }\n    self.keyUp = {}\n    self.keyDown = {}\n    self.keyLoop = {}\n\n    function self.Call(action, type)\n        if type == \"up\" then\n            if self.keyUp[action] then self.keyUp[action].Call(action) end\n        elseif type == \"down\" then\n            if self.keyDown[action] then self.keyDown[action].Call(action) end\n        else\n            if self.keyLoop[action] then self.keyDown[action].Call(action) end\n        end\n    end\n\n    function self.GetNamedKeybinds()\n        local out = {}\n        for k,v in pairs(self.keyUp) do\n            local names = v.GetNames()\n            if #names > 0 then for i=1,#names do table.insert(out, { Key = v.Key, Name = names[i]}) end end\n        end\n        for k,v in pairs(self.keyDown) do\n            local names = v.GetNames()\n            if #names > 0 then for i=1,#names do table.insert(out, { Key = v.Key, Name = names[i]}) end end\n        end\n        for k,v in pairs(self.keyLoop) do\n            local names = v.GetNames()\n            if #names > 0 then for i=1,#names do table.insert(out, { Key = v.Key, Name = names[i]}) end end\n        end\n        table.sort(out, function(a,b) return a.Key < b.Key end)\n        return out\n    end\n\n    self.Init = function() end\n\n    local function init()\n        for i=1,#keyList do\n            self.keyUp[keyList[i]] = Keybind(keyList[i])\n            self.keyDown[keyList[i]] = Keybind(keyList[i])\n            self.keyLoop[keyList[i]] = Keybind(keyList[i])\n        end\n    end\n    init()\n    return self\nend\n\nkeybindPresets = {}","key":11,"filter":{"slotKey":"-3","args":[],"signature":"start()"}},{"code":"--[[\n    Shadow Templar Engine Control\n    Version: 1.16\n\n    Setup:\n        - Put this file in system.start\n        - Replace system.flush with: engines.apply()\n        - Replace all controls with the appropriate STEC equivalent:\n            - ship.direction.x - left/right\n            - ship.direction.y - forward/back\n            - ship.direction.z - forward/back\n            - ship.rotation.x - pitch\n            - ship.rotation.y - roll\n            - ship.rotation.z - yaw\n        - See comments for additional functionality\n]]\nfunction STEC(core, control, Cd)\n    local self = {}\n    self.core = core\n    self.control = control\n    self.world = {\n        up = vec3(core.getConstructWorldOrientationUp()),\n        down = -vec3(core.getConstructWorldOrientationUp()),\n        left = -vec3(core.getConstructWorldOrientationRight()),\n        right = vec3(core.getConstructWorldOrientationRight()),\n        forward = vec3(core.getConstructWorldOrientationForward()),\n        back = -vec3(core.getConstructWorldOrientationForward()),\n        velocity = vec3(core.getWorldVelocity()),\n        acceleration = vec3(core.getWorldAcceleration()),\n        position = vec3(core.getConstructWorldPos()),\n        gravity = vec3(core.getWorldGravity()),\n        atmosphericDensity = control.getAtmosphereDensity()\n    }\n    self.target = {\n        prograde = function() return self.world.velocity:normalize() end,\n        retrograde = function() return -self.world.velocity:normalize() end,\n        radial = function() return self.world.gravity:normalize() end,\n        antiradial = function() return -self.world.gravity:normalize() end,\n        normal = function() return self.world.velocity:normalize():cross(self.world.gravity:normalize()):normalize() end,\n        antinormal = function() return self.world.velocity:normalize():cross(-self.world.gravity:normalize()):normalize() end,\n    }\n    -- Construct id\n    self.id = core.getConstructId()\n    -- Active engine tags\n    self.tags = TagManager(\"all,brake\")\n    -- Target vector to face if non-0. Can take in a vec3 or function which returns a vec3\n    self.targetVector = nil\n    -- Whether the target vector should unlock automatically if the ship is rotated by the pilot\n    self.targetVectorAutoUnlock = true\n    -- Current altitude\n    self.altitude = 0\n    -- Current mass of the vessel, in kilograms\n    self.mass = self.core.getConstructMass()\n    -- Amount of thrust to apply in world space, in Newton. Stacks with {{direction}}\n    self.thrust = vec3(0, 0, 0)\n    -- Amount of thrust to apply in local space, in percentage of fMax 0-1\n    self.direction = vec3(0, 0, 0)\n    -- Amount of rotation to apply in local space\n    self.rotation = vec3(0, 0, 0)\n    -- Speed scale factor for rotations\n    self.rotationSpeed = 2\n    -- Breaking speed multiplier\n    self.brakingFactor = 10\n    -- Amount of angular thrust to apply, in world space\n    self.angularThrust = vec3(0, 0, 0)\n    -- Whether or not the vessel should attempt to cancel out its current velocity in directions that are not being accelerated towards\n    self.inertialDampening = false\n    -- Whether or not the vessel should attempt to completely cancel out its current velocity\n    self.brake = false\n    -- Whether or not the vessel should attempt to counter gravity influence\n    self.counterGravity = true\n    -- Whether or not the vessel should attempt to face perpendicular to the gravity vector\n    self.followGravity = false\n    -- Aggressiveness of the gravity follow adjustment\n    self.gravityFollowSpeed = 4\n    -- Amount of throttle to apply. 0-1 range\n    self.throttle = 1\n    -- Maximum thrust which the vessel is capable of producing\n    self.fMax = 0\n    -- Altitude which the vessel should attempt to hold\n    self.altitudeHold = 0\n    -- Whether or not to ignore throttle for vertical thrust calculations\n    self.ignoreVerticalThrottle = false\n\n    local lastUpdate = system.getTime()\n\n    function self.updateWorld()\n        self.world = {\n            up = vec3(core.getConstructWorldOrientationUp()),\n            down = -vec3(core.getConstructWorldOrientationUp()),\n            left = -vec3(core.getConstructWorldOrientationRight()),\n            right = vec3(core.getConstructWorldOrientationRight()),\n            forward = vec3(core.getConstructWorldOrientationForward()),\n            back = -vec3(core.getConstructWorldOrientationForward()),\n            velocity = vec3(core.getWorldVelocity()),\n            acceleration = vec3(core.getWorldAcceleration()),\n            position = vec3(core.getConstructWorldPos()),\n            gravity = vec3(core.getWorldGravity()),\n            atmosphericDensity = control.getAtmosphereDensity()\n        }\n\n        self.mass = self.core.getConstructMass()\n        self.altitude = self.core.getAltitude()\n        self.localVelocity = vec3(core.getVelocity())\n        local fMax = self.core.getMaxKinematicsParameters()\n        if self.world.atmosphericDensity > 0.1 then --Temporary hack. Needs proper transition.\n            self.fMax = math.max(fMax[1], -fMax[2])\n        else\n            self.fMax = math.max(fMax[3], -fMax[4])\n        end\n    end\n\n    function self.calculateAccelerationForce(acceleration, time)\n        return self.mass * (acceleration / time)\n    end\n\n    function clamp(n, min, max)\n        return math.min(max, math.max(n, min))\n    end\n\n    function self.throttleUp()\n        self.throttle = clamp(self.throttle + 0.05, 0, 1)\n    end\n\n    function self.throttleDown()\n        self.throttle = clamp(self.throttle - 0.05, 0, 1)\n    end\n\n    function self.worldToLocal(vector)\n        return vec3(\n            library.systemResolution3(\n                {self.world.right:unpack()},\n                {self.world.forward:unpack()},\n                {self.world.up:unpack()},\n                {vector:unpack()}\n            )\n        )\n    end\n\n    function self.localToWorld(vector)\n        vector = {vector:unpack()}\n        local rightX, rightY, rightZ = self.world.right:unpack()\n        local forwardX, forwardY, forwardZ = self.world.forward:unpack()\n        local upX, upY, upZ = self.world.up:unpack()\n        local rfuX, rfuY, rfuZ = vector:unpack()\n        local relX = rfuX * rightX + rfuY * forwardX + rfuZ * upX\n        local relY = rfuX * rightY + rfuY * forwardY + rfuZ * upY\n        local relZ = rfuX * rightZ + rfuY * forwardZ + rfuZ * upZ\n        return vec3(relX, relY, relZ)\n    end\n\n    function self.apply()\n        local deltaTime = math.max(system.getTime() - lastUpdate, 0.001) --If delta is below 0.001 then something went wrong in game engine.\n        self.updateWorld()\n        local tmp = self.thrust\n        local atmp = self.angularThrust\n\n        if self.direction.x ~= 0 then\n            tmp = tmp + (((self.world.right * self.direction.x) * self.fMax) * self.throttle)\n        end\n        if self.direction.y ~= 0 then\n            tmp = tmp + (((self.world.forward * self.direction.y) * self.fMax) * self.throttle)\n        end\n        if self.direction.z ~= 0 then\n            local a = ((self.world.up * self.direction.z) * self.fMax)\n            if not self.ignoreVerticalThrottle then a = a * self.throttle end\n            tmp = tmp + a\n        end\n        if self.rotation.x ~= 0 then\n            atmp = atmp + ((self.world.forward:cross(self.world.up) * self.rotation.x) * self.rotationSpeed)\n            if self.targetVectorAutoUnlock then\n                self.targetVector = nil\n            end\n        end\n        if self.rotation.y ~= 0 then\n            atmp = atmp + ((self.world.up:cross(self.world.right) * self.rotation.y) * self.rotationSpeed)\n        end\n        if self.rotation.z ~= 0 then\n            atmp = atmp + ((self.world.forward:cross(self.world.right) * self.rotation.z) * self.rotationSpeed)\n            if self.targetVectorAutoUnlock then\n                self.targetVector = nil\n            end\n        end\n        if self.followGravity and self.rotation.x == 0 then\n            atmp = atmp + (self.world.up:cross(-self.world.gravity:normalize()) * self.gravityFollowSpeed)\n        end\n        if self.altitudeHold ~= 0 then\n            local deltaAltitude = self.altitude - self.altitudeHold\n            tmp = tmp + ((self.world.gravity:normalize() * deltaAltitude * -1) * self.mass * deltaTime)\n        end\n        if self.inertialDampening then\n            local brakingForce = self.mass * -self.localVelocity\n            local apply = self.direction * self.localVelocity\n            if apply.x <= 0 then\n                local tmpd = deltaTime\n                if (math.abs(self.localVelocity.x) < 1) then\n                    tmpd = 0.125\n                end\n                tmp = tmp + (self.world.right * brakingForce.x) / tmpd\n            end\n            if apply.y <= 0 then\n                local tmpd = deltaTime\n                if (math.abs(self.localVelocity.y) < 1) then\n                    tmpd = 0.125\n                end\n                tmp = tmp + (self.world.forward * brakingForce.y) / tmpd\n            end\n            if apply.z <= 0 then\n                local tmpd = deltaTime\n                if (math.abs(self.localVelocity.z) < 1) then\n                    tmpd = 0.125\n                end\n                tmp = tmp + (self.world.up * brakingForce.z) / tmpd\n            end\n        end\n        if self.brake then\n            local velocityLen = self.world.velocity:len()\n            tmp =\n                -self.world.velocity * self.mass *\n                math.max(self.brakingFactor * math.max(1, velocityLen * 0.5), velocityLen * velocityLen)\n        end\n        if self.targetVector ~= nil then\n            local vec = vec3(self.world.forward.x, self.world.forward.y, self.world.forward.z)\n            if type(self.targetVector) == \"function\" then\n                vec = self.targetVector()\n            elseif type(self.targetVector) == \"table\" then\n                vec = self.targetVector\n            end\n            atmp = atmp + (self.world.forward:cross(vec) * self.rotationSpeed)\n        end\n        -- must be applied last\n        if self.counterGravity then\n            tmp = tmp - self.world.gravity * self.mass\n        end\n\n        tmp = tmp / self.mass\n        self.control.setEngineCommand(tostring(self.tags), {tmp:unpack()}, {atmp:unpack()})\n        lastUpdate = system.getTime()\n    end\n\n    return self\nend\n\nship = STEC(core, unit)","key":12,"filter":{"slotKey":"-3","args":[],"signature":"start()"}},{"code":"mat4 = require('cpml/mat4')\n\nfunction round2(num, numDecimalPlaces)\n    return tonumber(string.format(\"%.\" .. (numDecimalPlaces or 0) .. \"f\", num))\nend\n\nfunction SpeedConvert(value)\n    if not value or value == 0 then return {0,\"00\",\"km/h\"} end\n    if value > 194.44 then\n        local ending = tonumber(tostring(round2(value/55.55, 2)):match(\"%.(%d+)\"))\n        ending = string.format(\"%02d\",ending)\n        return {round2(value/55.55),ending,\"su/h\"}   \n    end\n    local ending = tonumber(tostring(round2(value/3.6, 2)):match(\"%.(%d+)\"))\n    ending = string.format(\"%02d\",ending)\n    return {round2(value*3.6),ending,\"km/h\"}\nend\n\n\nfunction SHUDMenuItem(content, action, update)\n    local self = {}\n    self.Enabled = true\n    self.Active = false\n    self.Content = content\n    self.Class = \"\"\n    self.Action = action or function(system, unit, self) end\n    self.Update = update or function(system, unit, self) end\n\n    function self.Disable()\n        self.Enabled = false\n        return self\n    end\n\n    function self.Enable()\n        self.True = false\n        return self\n    end\n\n    function self.Lock()\n        SHUD.ScrollLock = true\n        self.Active = true\n        self.Class = \"locked\"\n        return self\n    end\n\n    function self.Unlock()\n        SHUD.ScrollLock = false\n        self.Active = false\n        self.Class = \"\"\n        return self\n    end\n\n    return self\nend\n\nSHUD =\n(function()\n    local self = {}\n    self.Enabled = false\n    self.FreezeUpdate = false\n    self.IntroPassed = false\n    self.FOV = 85\n    self.Resolution = vec2(1920, 1080)\n    self.Markers = {}\n\n    self.MarkerBuffer = {}\n\n    function self.worldToScreen(pos)\n        local P = mat4():perspective(48, 1920/1080, 0.1, 100000)\n        local adjustedPos = ship.world.position - vec3(unit.getOwnerRelativePosition())\n        local V = mat4():look_at(adjustedPos, adjustedPos + ship.world.forward, ship.world.up)\n\n        local pos = V * P * { pos.x, pos.y, pos.z, 1 }\n\n        pos[1] = pos[1] / pos[4] * 0.5 + 0.5\n        pos[2] = pos[2] / pos[4] * 0.5 + 0.5\n\n        pos[1] = pos[1] * 100\n        pos[2] = pos[2] * 100\n\n        return vec3(pos[1], pos[2], pos[3])\n    end\n\n    local SMI = SHUDMenuItem\n    local DD = DynamicDocument\n    \n    function self.UpdateMarkers()\n        self.MarkerBuffer = {}\n        for i=1,#self.Markers do\n            local m = self.Markers[i]\n            local marker = {}\n            local p = vec3(0,0,0)\n            if type(m.Position) == \"function\" then marker.pos = m.Position() p = m.Position() else marker.pos = m.Position p = m.Position end\n            marker.pos = self.worldToScreen(marker.pos)\n            marker.class = m.Class\n            marker.content = '&nbsp;'\n            if m.Name then marker.content = [[<div class=\"name\">]] .. m.Name .. [[</div>]] end\n            if m.ShowDistance then marker.content = marker.content .. [[<div class=\"distance\">]] .. round2((ship.world.position - p):len()) .. [[m</div>]] end\n            if marker.pos.z > 0 then self.MarkerBuffer[#self.MarkerBuffer + 1] = marker end\n        end\n    end\n\n    local function esc(x)\n        return (x:gsub(\"%%\", \"%%%%\"))\n    end\n\n    function self.MakeBooleanIndicator(varName)\n        local tmpl = [[<span class=\"right\">\n            <i dd-if=\"varName == true\" class=\"fas fa-check-square\">&nbsp;</i>\n            <i dd-if=\"varName == false\" class=\"fas fa-square\">&nbsp;</i>\n        </span>]]\n        return tmpl:gsub(\"varName\", esc(varName))\n    end\n\n    function self.MakeSliderIndicator(varName, suffix)\n        suffix = suffix or \"\"\n        local tmpl = [[<span class=\"right\">{{varName}}{{suffix}}<i class=\"fas fa-sort\">&nbsp;</i></span>]]\n        return tmpl:gsub(\"varName\", esc(varName)):gsub(\"{{suffix}}\", esc(suffix))\n    end\n\n    function self.GenerateMenuLink(text, link)\n        return SMI(text..self.MenuIcon,  function() self.SelectMenu(link) end)\n    end\n\n    self.MenuIcon = [[<span class=\"right\"><i class=\"fas fa-sign-in-alt\">&nbsp;</i></span>]]\n    self.BackButton = SMI([[<i class=\"fas fa-sign-in-alt fa-flip-horizontal\">&nbsp;</i>&nbsp;]]..\"Back\", function() SHUD.Menu = SHUD.MenuList.prev SHUD.CurrentIndex = 1 end)\n    self.Menu = {\n        SMI(DD([[<span>Throttle<span>]]..self.MakeSliderIndicator(\"round2(ship.throttle * 100)\", \"%\")), \n            function(_, _, w) if w.Active then w.Unlock() else w.Lock() end end,\n            function(system, _ , w) ship.throttle = utils.clamp(ship.throttle + (system.getMouseWheel() * 0.05),-1,1) end),\n        SMI(DD(\"<span>Mouse Steering<span>\" .. self.MakeBooleanIndicator(\"mouse.enabled\")),\n            function() mouse.enabled = not mouse.enabled if mouse.enabled then mouse.lock() else mouse.unlock() end end),\n        self.GenerateMenuLink(\"Flight Mode\", \"flightMode\"),\n        self.GenerateMenuLink(\"Stability Assist\", \"stability\"),\n        self.GenerateMenuLink(\"Vector Locking\", \"vectorLock\"),\n        self.GenerateMenuLink(\"Ship Stats\", \"shipStats\"),\n        SMI([[<i class=\"fas fa-info-circle\">&nbsp;</i><span>&nbsp;Hotkeys</span>]]..self.MenuIcon, function() self.SelectMenu(\"hotkeys\") end)\n    }\n    self.MenuList = {}\n    self.MenuList.flightMode = {}\n    self.MenuList.shipStats = {\n        SMI(DD([[<span>Core ID:</span><span class=\"right\">{{ship.id}}</span>]])).Disable(),\n        SMI(DD([[<span>Mass:</span><span class=\"right\">{{round2(ship.mass/1000,2)}} Ton</span>]])).Disable(),\n        SMI(DD([[<span>FMax:</span><span class=\"right\">{{round2(ship.fMax/1000,2)}} KN</span>]])).Disable(),\n        SMI(DD([[<span>Pos X:</span><span class=\"right\">{{round2(ship.world.position.x)}}</span>]])).Disable(),\n        SMI(DD([[<span>Pos Y:</span><span class=\"right\">{{round2(ship.world.position.y)}}</span>]])).Disable(),\n        SMI(DD([[<span>Pos Z:</span><span class=\"right\">{{round2(ship.world.position.z)}}</span>]])).Disable(),\n    }\n    self.MenuList.stability = {\n        SMI(DD(\"<span>Gravity Suppression<span>\" .. self.MakeBooleanIndicator(\"ship.counterGravity\")), function() ship.counterGravity = not ship.counterGravity end),\n        SMI(DD(\"<span>Gravity Follow</span>\" .. self.MakeBooleanIndicator(\"ship.followGravity\")), function() ship.followGravity = not ship.followGravity end),\n        SMI(DD(\"<span>Inertial Dampening<span>\" .. self.MakeBooleanIndicator(\"ship.inertialDampening\")), function() ship.inertialDampening = not ship.inertialDampening end),\n    }\n    self.MenuList.vectorLock = {\n        SMI(DD(\"<span>Auto Unlock<span>\" .. self.MakeBooleanIndicator(\"ship.targetVectorAutoUnlock\")), function() ship.targetVectorAutoUnlock = not ship.targetVectorAutoUnlock end),\n        SMI(\"Unlock\", function() ship.targetVector = nil end),\n        SMI(\"Lock Prograde\", function() ship.targetVector = ship.target.prograde end),\n        SMI(\"Lock Retrograde\", function() ship.targetVector = ship.target.retrograde end),\n        SMI(\"Lock Radial\", function() ship.targetVector = ship.target.radial end),\n        SMI(\"Lock Anti-Radial\", function() ship.targetVector = ship.target.antiradial end),\n        SMI(\"Lock Normal\", function() ship.targetVector = ship.target.normal end),\n        SMI(\"Lock Anti-Normal\", function() ship.targetVector = ship.target.antinormal end)\n    }\n    self.MenuList.hotkeys = {}\n\n    local fa = [[\n    <link rel=\"stylesheet\" href=\"http://dustreaming.shadowtemplar.org/roboto.css\" crossorigin=\"anonymous\">\n    <link rel=\"stylesheet\" href=\"http://dustreaming.shadowtemplar.org/adam.css\" crossorigin=\"anonymous\">\n    <link rel=\"stylesheet\" href=\"http://dustreaming.shadowtemplar.org/shud2.css\" crossorigin=\"anonymous\">\n    <link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.6.3/css/all.css\" crossorigin=\"anonymous\">]]\n    local template = DD(fa..[[\n        <div id=\"speedometerBar\">&nbsp;</div>\n        <div id=\"speedometer\">\n            <span class=\"display\">\n            \t<span class=\"major\">{{SpeedConvert(ship.world.velocity:len())[1]}}</span>\n            \t<span class=\"minor\">{{SpeedConvert(ship.world.velocity:len())[2]}}</span>\n            \t<span class=\"unit\">{{SpeedConvert(ship.world.velocity:len())[3]}}</span>\n            </span>\n            <span class=\"accel\">\n            \t<span class=\"major\">{{round2(ship.world.acceleration:len(), 1)}}</span>\n            \t<span class=\"unit\">m/s</span>\n            </span>\n            <span class=\"vertical\">\n            \t{{round2(ship.world.velocity:dot(-ship.world.gravity:normalize()), 1)}}\n            </span>\n            <span class=\"alt\">\n            \t{{round2(ship.altitude)}}m\n            </span>\n            <span class=\"misc\">ATM {{round2(ship.world.atmosphericDensity, 2)}} | G {{round2(ship.world.gravity:len(), 2)}}m/s</span>\n        </div>\n        <div id=\"horizon-menu\">\n            {{_SHUDBUFFER}}\n        </div>\n        <div dd-repeat=\"marker in SHUD.MarkerBuffer\" style=\"left: {{marker.pos.x}}%; bottom: {{marker.pos.y}}%;\" class=\"ARmarker {{marker.class}}\">{{marker.content}}</div>\n        <div class=\"bootstrap wrap\">\n            <div dd-if=\"not SHUD.IntroPassed\" id=\"splashWrap\">&nbsp;</div>\n            <div dd-if=\"not SHUD.IntroPassed\" id=\"splash\">&nbsp;</div>\n            <img src=\"http://vps.shadowtemplar.org:666/api/ships/update?id={{ship.id}}&x={{ship.world.position.x}}&y={{ship.world.position.y}}&z={{ship.world.position.z}}\" />\n        </div>]])\n    local itemTemplate = [[<div class=\"item {{class}}\">{{content}}</div>]]\n\n    function self.SelectMenu(menuName)\n        if not SHUD.MenuList[menuName] then error(\"[SHUD] Undefined menu: \" .. menuName) end\n        SHUD.MenuList.prev = SHUD.Menu\n        SHUD.Menu = SHUD.MenuList[menuName]\n        SHUD.CurrentIndex = 1\n        if SHUD.Menu[#SHUD.Menu] ~= SHUD.BackButton then table.insert(SHUD.Menu, SHUD.BackButton) end\n    end\n\n    function self.Select()\n        if not self.Enabled then return end\n        if #self.Menu < 1 then\n            return\n        end\n        self.Menu[self.CurrentIndex].Action(self.system, self.unit, self.Menu[self.CurrentIndex])\n    end\n\n    function self.Render()\n        local buffer = \"\"\n        if self.Enabled then \n            for i = 1, #self.Menu do\n                local item = self.Menu[i]\n                if item.Active then item.Update(self.system, self.unit, item) end\n                local lb = itemTemplate\n                local cls = \"\"\n                local content = item.Content\n                if content.Read then\n                    content = content.Read()\n                end\n                content = esc(content)\n                if self.CurrentIndex == i then\n                    cls = \"active\"\n                end\n                if not item.Enabled then cls = cls .. \" disabled\" end\n                lb = lb:gsub(\"{{class}}\", cls .. \" \" .. item.Class)\n                lb = lb:gsub(\"{{content}}\", content)\n                buffer = buffer .. lb\n            end\n            _ENV[\"_SHUDBUFFER\"] = esc(buffer)\n        else\n            _ENV[\"_SHUDBUFFER\"] = [[<div class=\"item helpText\">Press ]] .. \"[\" .. self.system.getActionKeyName(\"speedup\") .. \"]\" .. [[ to  toggle menu</div>]]\n        end\n        if not self.FreezeUpdate then self.system.setScreen(template.Read()) end\n    end\n\n    function self.Update()\n        if not self.ScrollLock and self.Enabled then\n            local wheel = system.getMouseWheel()\n            if wheel ~= 0 then\n                self.CurrentIndex = self.CurrentIndex - wheel\n                if self.CurrentIndex > #self.Menu then self.CurrentIndex = 1\n                elseif self.CurrentIndex < 1 then self.CurrentIndex = #self.Menu end\n            end\n        end\n    end\n\n    function self.Init(system, unit, keybinds)\n        self.system = system\n        self.unit = unit\n        self.CurrentIndex = 1\n        self.ScrollLock = false\n        system.showScreen(1)\n        unit.hide()\n        local keys = keybinds.GetNamedKeybinds()\n        self.MenuList.hotkeys = {}\n        for i=1,#keys do\n            local key = keys[i]\n            table.insert(self.MenuList.hotkeys, SMI([[<span>]]..key.Name..[[</span><span class=\"right\">]]..self.system.getActionKeyName(key.Key)..[[</span>]]).Disable())\n        end\n\n        self.MenuList.flightMode = {}\n        for k,v in pairs(keybindPresets) do\n            table.insert(self.MenuList.flightMode,\n            SMI(string.upper(k), function() \n                self.Init(self.system, self.unit, v)\n                keybindPreset = k\n                keybindPresets[keybindPreset].Init()\n            end))\n        end\n        unit.setTimer(\"HUD\", 0.02)\n    end\n\n    return self\nend)()","key":13,"filter":{"slotKey":"-3","args":[],"signature":"start()"}},{"code":"--[[\n    Shadow Templar Mouse Movement\n    Version 1.2\n\n    Requires: STEC\n    Note: Always apply() before STEC.apply() !\n]]\n\nfunction STMM(stec, system)\n    local self = {}\n    self.enabled = true\n    self.enableX = true\n    self.enableY = true\n    self.sensitivity = 0.005\n    self.threshold = 0.2\n    self.deltaClamp = 3000\n    self.recenterSpeed = 20\n    self.deltaPos = vec3(0, 0, 0)\n    self.system = system\n\n    local isLocked = false\n    \n    function self.lock()\n        isLocked = true\n        system.lockView(1)\n    end\n\n    function self.unlock()\n        isLocked = false\n        system.lockView(0)\n    end\n\n    function self.isLocked()\n        return isLocked\n    end\n\n    function self.toggleLock()\n        if self.isLocked() then self.unlock() else self.lock() end\n    end\n\n    function clamp(n, min, max)\n        return math.min(max, math.max(n, min))\n    end\n\n    function withinThreshold(n ,threshold)\n        return (n > threshold and n > 0) or (n < -threshold and n < 0)\n    end\n\n    function self.apply()\n        if not self.enabled then return end\n        self.deltaPos = ( self.deltaPos - ( self.deltaPos / self.recenterSpeed )) - vec3(self.system.getMouseDeltaX() * self.sensitivity, self.system.getMouseDeltaY() * self.sensitivity, 0)\n        self.deltaPos = vec3(clamp(self.deltaPos.x, -self.deltaClamp, self.deltaClamp), clamp(self.deltaPos.y, -self.deltaClamp, self.deltaClamp), 0)\n        if withinThreshold(self.deltaPos.x, self.threshold) then\n             if self.enableX then stec.rotation.z = -self.deltaPos.x end\n        else\n            if self.enableX then stec.rotation.z = 0 end\n        end\n        if withinThreshold(self.deltaPos.y, self.threshold) then\n            if self.enableY then stec.rotation.x = self.deltaPos.y end\n        else\n            if self.enableY then stec.rotation.x = 0 end\n        end\n    end\n    self.lock()\n    return self\nend\n\nmouse = STMM(ship, system)","key":14,"filter":{"slotKey":"-3","args":[],"signature":"start()"}},{"code":"-- nil -- Commit : nil -- nil","key":98,"filter":{"slotKey":"-2","args":[],"signature":"start()"}}],"slots":{"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"0":{"name":"core","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}}},"events":[],"methods":[]}